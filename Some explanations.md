# Пояснения к структуре backend-проекта (.NET)

Здесь объяснены слои проекта, ключевые термины и как всё это связано между собой.

## 1) Из чего состоит проект

- `Domain` (Доменная модель)
  - Содержит классы-сущности предметной области: `User`, `Project`, `Diagram`, `SourceFile`, и т. д.
  - Здесь нет работы с базой данных и внешними сервисами — только данные и правила для этих данных.

- `Application` (Слой приложений)
  - Описывает контракты (интерфейсы) бизнес‑логики: сервисы (`IDiagramService`, `ISyncService` и др.) и репозитории (`IProjectRepository`, `IDiagramRepository`, …).
  - Здесь почти нет «реализаций» — в основном интерфейсы и DTO. Это позволяет легко подменять реализацию и тестировать логику.

- `Infrastructure` (Инфраструктура)
  - Реализует доступ к базе данных (EF Core), репозитории, Unit of Work, внешние интеграции.
  - Содержит `AppDbContext` — контекст базы данных.
  - В файле `DependencyInjection.cs` регистрируются реализации интерфейсов в контейнере зависимостей (см. DI).

- `WebApi` (Веб‑слой)
  - Точка входа в приложение (HTTP API).
  - `Program.cs` настраивает DI, БД, Swagger.
  - Здесь находятся контроллеры/эндпоинты, которые принимают запросы от фронтенда.


## 2) Ключевые термины

- DI (Dependency Injection) — «Внедрение зависимостей»
  - Способ передавать объектам их зависимости извне, а не создавать их внутри.
  - Мы регистрируем интерфейсы и их реализации (например, `IProjectRepository -> ProjectRepository`) в контейнере. Когда где‑то нужен `IProjectRepository`, контейнер создаёт `ProjectRepository` и передаёт его.
  - Плюсы: код легче тестировать и изменять, меньше «жёстких связей».

- Репозиторий (Repository)
  - Паттерн для инкапсуляции доступа к данным.
  - Интерфейс (например, `IProjectRepository`) описывает, что можно делать: «получить проект», «сохранить проект» и т. п.
  - Реализация (например, `ProjectRepository`) знает, как именно это сделать в БД (через EF Core).
  - Бонус: остальная логика не зависит от конкретной БД.

- Unit of Work (UoW) — «Единица работы»
  - Координирует сохранение изменений в БД как одну транзакцию.
  - Собираем несколько операций репозиториев и в конце одним вызовом `SaveChangesAsync()` фиксируем результат.
  - Это помогает обеспечить целостность: либо всё успешно, либо ничего не сохранено.

- DbContext (EF Core)
  - Класс EF Core, представляющий подключение к БД и набор таблиц (DbSet).
  - В проекте это `AppDbContext`: `Users`, `Projects`, `Diagrams`, …
  - Через контекст выполняются запросы, добавление/обновление/удаление данных.

- Миграции (EF Core Migrations)
  - Механизм версионирования схемы БД.
  - Команды: `dotnet ef migrations add <Имя>` — создать миграцию, `dotnet ef database update` — применить её к БД.
  - Мы уже сделали миграцию `Init` и применили её.

- Контроллер / Эндпоинт (Web API)
  - «Входные двери» в систему по HTTP (например, `GET /api/projects`).
  - Контроллер получает запрос, вызывает нужные сервисы/репозитории, возвращает ответ в формате JSON.

- DTO (Data Transfer Object)
  - Простые классы для передачи данных наружу/вовнутрь API (не обязательно совпадают с доменными сущностями).
  - Помогают отделить внутреннюю модель от внешнего контракта API.

- Swagger (OpenAPI)
  - Автоматическая документация и тестирование API через браузер.
  - Доступно на дев‑окружении. Удобно для изучения и ручной проверки эндпоинтов.


## 3) Как данные «идут» через слои

1. Клиент (например, фронтенд) вызывает HTTP эндпоинт WebApi.
2. Эндпоинт обращается к сервисам/репозиториям, объявленным в `Application` (по интерфейсам).
3. Контейнер DI подставляет реализации из `Infrastructure`.
4. Реализация через `AppDbContext` (EF Core) читает/пишет в БД.
5. Результат возвращается наверх, при необходимости маппится в DTO и отдается клиенту.


## 4) Где что зарегистрировано

- `WebApi/Program.cs`
  - Регистрация Swagger, чтение конфигурации, строка подключения к Postgres, `AddDbContext<AppDbContext>()`.
  - Вызов `builder.Services.AddInfrastructure();` — регистрирует репозитории и Unit of Work.

- `Infrastructure/DependencyInjection.cs`
  - Методы расширения для DI: `AddInfrastructure()` добавляет все реализации интерфейсов (`IProjectRepository`, `IDiagramRepository`, `IUnitOfWork`, и т. д.).


## 5) Как запустить и где настраивать БД

- Запуск API:
  - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
  - Откройте корневой эндпоинт `/` или Swagger в Dev‑режиме.

- Настройка строки подключения (PostgreSQL):
  - Файлы: `src/WebApi/appsettings.Development.json` (локально), `appsettings.json` (по умолчанию).
  - Можно задать через переменные окружения: `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`.


## 6) Куда смотреть студенту в первую очередь

1. `Domain/Entities` — понять, какие данные хранит система.
2. `Application/Repositories` — посмотреть, какие операции с данными требуются.
3. `Infrastructure/Repositories` — увидеть, как эти операции реализованы на EF Core.
4. `WebApi/Program.cs` — как подключается БД и DI, где включается Swagger.
5. Swagger UI — посмотреть и «пощупать» API запросами.


## 7) Частые вопросы

- Почему мы разделяем на слои?
  - Чтобы код было легче поддерживать, тестировать и расширять. Слои уменьшают «спутывание» зависимостей.

- Зачем интерфейсы и DI?
  - Можно подменить реализацию (например, на фейковую в тестах) без изменения остального кода.

- Чем сущность отличается от DTO?
  - Сущность — внутренняя модель (как мы храним/обрабатываем данные). DTO — внешний контракт (как мы отдаём/принимаем данные в API).

- Зачем Unit of Work?
  - Чтобы несколько операций сохранялись «атомарно» — либо все изменения вместе, либо ни одно.

Если остались вопросы — лучше всего открыть Swagger и пройтись по эндпоинтам, параллельно заглядывая в код соответствующих репозиториев/сервисов. Это быстро даст понимание, как всё связано. 

## 8) Как тестировать API через Swagger

Swagger уже подключён в Dev-окружении. Это удобный способ руками вызвать эндпоинты и увидеть структуру запросов/ответов.

Шаги:
1. Запустите API:
   - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
2. Откройте браузер и перейдите:
   - Swagger UI: обычно `http://localhost:5143/swagger` (точный порт смотрите в `launchSettings.json`)
3. В Swagger UI:
   - Выберите нужный контроллер (например, `Projects`).
   - Раскройте метод (GET/POST/PUT/DELETE) и нажмите `Try it out`.
   - Заполните параметры/тело запроса и нажмите `Execute`.
   - Снизу увидите фактический запрос, статус-код и JSON-ответ.

Полезно:
- Вкладка `Schemas` показывает модели/DTO, которые использует API.
- Если метод требует body, Swagger подставит шаблон JSON — отредактируйте и отправьте.
- Для проверки соединения с БД начните с простых запросов `GET` (например, `GET /api/projects?ownerId=...`).

Альтернатива (curl/Postman):
- Любой запрос, показанный Swagger’ом, можно скопировать как cURL и выполнить в терминале, либо собрать вручную в Postman/Insomnia.



# Пояснения к структуре backend-проекта (.NET)

Здесь объяснены слои проекта, ключевые термины и как всё это связано между собой.

## 1) Из чего состоит проект

- `Domain` (Доменная модель)
  - Содержит классы-сущности предметной области: `User`, `Project`, `Diagram`, `SourceFile`, и т. д.
  - Здесь нет работы с базой данных и внешними сервисами — только данные и правила для этих данных.

- `Application` (Слой приложений)
  - Описывает контракты (интерфейсы) бизнес‑логики: сервисы (`IDiagramService`, `ISyncService` и др.) и репозитории (`IProjectRepository`, `IDiagramRepository`, …).
  - Здесь почти нет «реализаций» — в основном интерфейсы и DTO. Это позволяет легко подменять реализацию и тестировать логику.

- `Infrastructure` (Инфраструктура)
  - Реализует доступ к базе данных (EF Core), репозитории, Unit of Work, внешние интеграции.
  - Содержит `AppDbContext` — контекст базы данных.
  - В файле `DependencyInjection.cs` регистрируются реализации интерфейсов в контейнере зависимостей (см. DI).

- `WebApi` (Веб‑слой)
  - Точка входа в приложение (HTTP API).
  - `Program.cs` настраивает DI, БД, Swagger.
  - Здесь находятся контроллеры/эндпоинты, которые принимают запросы от фронтенда.


## 2) Ключевые термины

- DI (Dependency Injection) — «Внедрение зависимостей»
  - Способ передавать объектам их зависимости извне, а не создавать их внутри.
  - Мы регистрируем интерфейсы и их реализации (например, `IProjectRepository -> ProjectRepository`) в контейнере. Когда где‑то нужен `IProjectRepository`, контейнер создаёт `ProjectRepository` и передаёт его.
  - Плюсы: код легче тестировать и изменять, меньше «жёстких связей».

- Репозиторий (Repository)
  - Паттерн для инкапсуляции доступа к данным.
  - Интерфейс (например, `IProjectRepository`) описывает, что можно делать: «получить проект», «сохранить проект» и т. п.
  - Реализация (например, `ProjectRepository`) знает, как именно это сделать в БД (через EF Core).
  - Бонус: остальная логика не зависит от конкретной БД.

- Unit of Work (UoW) — «Единица работы»
  - Координирует сохранение изменений в БД как одну транзакцию.
  - Собираем несколько операций репозиториев и в конце одним вызовом `SaveChangesAsync()` фиксируем результат.
  - Это помогает обеспечить целостность: либо всё успешно, либо ничего не сохранено.

- DbContext (EF Core)
  - Класс EF Core, представляющий подключение к БД и набор таблиц (DbSet).
  - В проекте это `AppDbContext`: `Users`, `Projects`, `Diagrams`, …
  - Через контекст выполняются запросы, добавление/обновление/удаление данных.

- Миграции (EF Core Migrations)
  - Механизм версионирования схемы БД.
  - Команды: `dotnet ef migrations add <Имя>` — создать миграцию, `dotnet ef database update` — применить её к БД.
  - Мы уже сделали миграцию `Init` и применили её.

- Контроллер / Эндпоинт (Web API)
  - «Входные двери» в систему по HTTP (например, `GET /api/projects`).
  - Контроллер получает запрос, вызывает нужные сервисы/репозитории, возвращает ответ в формате JSON.

- DTO (Data Transfer Object)
  - Простые классы для передачи данных наружу/вовнутрь API (не обязательно совпадают с доменными сущностями).
  - Помогают отделить внутреннюю модель от внешнего контракта API.

- Swagger (OpenAPI)
  - Автоматическая документация и тестирование API через браузер.
  - Доступно на дев‑окружении. Удобно для изучения и ручной проверки эндпоинтов.


## 3) Как данные «идут» через слои

1. Клиент (например, фронтенд) вызывает HTTP эндпоинт WebApi.
2. Эндпоинт обращается к сервисам/репозиториям, объявленным в `Application` (по интерфейсам).
3. Контейнер DI подставляет реализации из `Infrastructure`.
4. Реализация через `AppDbContext` (EF Core) читает/пишет в БД.
5. Результат возвращается наверх, при необходимости маппится в DTO и отдается клиенту.


## 4) Где что зарегистрировано

- `WebApi/Program.cs`
  - Регистрация Swagger, чтение конфигурации, строка подключения к Postgres, `AddDbContext<AppDbContext>()`.
  - Вызов `builder.Services.AddInfrastructure();` — регистрирует репозитории и Unit of Work.

- `Infrastructure/DependencyInjection.cs`
  - Методы расширения для DI: `AddInfrastructure()` добавляет все реализации интерфейсов (`IProjectRepository`, `IDiagramRepository`, `IUnitOfWork`, и т. д.).


## 5) Как запустить и где настраивать БД

- Запуск API:
  - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
  - Откройте корневой эндпоинт `/` или Swagger в Dev‑режиме.

- Настройка строки подключения (PostgreSQL):
  - Файлы: `src/WebApi/appsettings.Development.json` (локально), `appsettings.json` (по умолчанию).
  - Можно задать через переменные окружения: `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`.


## 6) Куда смотреть студенту в первую очередь

1. `Domain/Entities` — понять, какие данные хранит система.
2. `Application/Repositories` — посмотреть, какие операции с данными требуются.
3. `Infrastructure/Repositories` — увидеть, как эти операции реализованы на EF Core.
4. `WebApi/Program.cs` — как подключается БД и DI, где включается Swagger.
5. Swagger UI — посмотреть и «пощупать» API запросами.


## 7) Частые вопросы

- Почему мы разделяем на слои?
  - Чтобы код было легче поддерживать, тестировать и расширять. Слои уменьшают «спутывание» зависимостей.

- Зачем интерфейсы и DI?
  - Можно подменить реализацию (например, на фейковую в тестах) без изменения остального кода.

- Чем сущность отличается от DTO?
  - Сущность — внутренняя модель (как мы храним/обрабатываем данные). DTO — внешний контракт (как мы отдаём/принимаем данные в API).

- Зачем Unit of Work?
  - Чтобы несколько операций сохранялись «атомарно» — либо все изменения вместе, либо ни одно.

Если остались вопросы — лучше всего открыть Swagger и пройтись по эндпоинтам, параллельно заглядывая в код соответствующих репозиториев/сервисов. Это быстро даст понимание, как всё связано. 

## 8) Как тестировать API через Swagger

Swagger уже подключён в Dev-окружении. Это удобный способ руками вызвать эндпоинты и увидеть структуру запросов/ответов.

Шаги:
1. Запустите API:
   - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
2. Откройте браузер и перейдите:
   - Swagger UI: обычно `http://localhost:5143/swagger` (точный порт смотрите в `launchSettings.json`)
3. В Swagger UI:
   - Выберите нужный контроллер (например, `Projects`).
   - Раскройте метод (GET/POST/PUT/DELETE) и нажмите `Try it out`.
   - Заполните параметры/тело запроса и нажмите `Execute`.
   - Снизу увидите фактический запрос, статус-код и JSON-ответ.

Полезно:
- Вкладка `Schemas` показывает модели/DTO, которые использует API.
- Если метод требует body, Swagger подставит шаблон JSON — отредактируйте и отправьте.
- Для проверки соединения с БД начните с простых запросов `GET` (например, `GET /api/projects?ownerId=...`).

Альтернатива (curl/Postman):
- Любой запрос, показанный Swagger'ом, можно скопировать как cURL и выполнить в терминале, либо собрать вручную в Postman/Insomnia.


## 9) Нововведения и реализованный функционал

### Система ролей и прав доступа

Проект использует систему ролей для управления доступом:

- **Owner (Владелец)**
  - Полный контроль над проектом
  - Может передавать владение другому участнику
  - Может изменять роли всех участников
  - Не может быть исключен из проекта

- **Admin (Администратор)**
  - Может управлять участниками (добавлять, изменять роли, исключать)
  - Может отправлять приглашения
  - Не может передавать владение или изменять роль owner
  - Не может исключить самого себя

- **Reviewer (Ревьюер)**
  - Может просматривать проект и создавать ревью
  - Может комментировать элементы ревью
  - Не может управлять участниками

**Политики авторизации:**
- `ProjectRead` — доступ для public/reviewer/admin/owner
- `ProjectWrite` — доступ для public/reviewer/admin/owner (создание ревью, комментариев)
- `ProjectAdmin` — только admin и owner (управление участниками, настройками)

### Система приглашений (Invitations)

Реализован полноценный механизм приглашений пользователей в проекты:

- **InvitationService** (`Infrastructure/Services/InvitationService.cs`)
  - Отправка приглашений с указанием роли
  - Автоматическое истечение через 7 дней
  - Проверка дубликатов и прав доступа

- **InvitationsController** (`WebApi/Controllers/InvitationsController.cs`)
  - `POST /api/projects/{projectId}/invitations` — отправить приглашение
  - `GET /api/projects/{projectId}/invitations` — список приглашений проекта
  - `GET /api/invitations` — список приглашений текущего пользователя
  - `POST /api/invitations/{invitationId}/accept` — принять приглашение
  - `POST /api/invitations/{invitationId}/reject` — отклонить приглашение
  - `DELETE /api/projects/{projectId}/invitations/{invitationId}` — отменить приглашение

**Особенности:**
- При принятии приглашения пользователь автоматически добавляется в участники проекта
- Статусы: `pending`, `accepted`, `rejected`, `expired`, `canceled`
- Проверка прав: только admin/owner могут отправлять и отменять приглашения

### Система ревью (Reviews)

Реализована комплексная система ревью кода и диаграмм:

- **ReviewService** (`Infrastructure/Services/ReviewService.cs`)
  - Создание ревью для версий диаграмм или исходных файлов
  - Управление статусами ревью (open, approved, changes_requested)
  - Приоритизация ревьюеров на основе ролей
  - Валидация правил ревью из `RequiredReviewersRules`

- **ReviewsController** (`WebApi/Controllers/ReviewsController.cs`)
  - Управление ревью: создание, просмотр, обновление статуса, удаление
  - Управление элементами ревью (items): комментарии и issues с привязкой к коду/диаграмме
  - Система комментариев: добавление, просмотр, редактирование, удаление

**Структура ревью:**
- **Review** — основная сущность ревью (привязана к версии диаграммы или файла)
- **ReviewItem** — элемент ревью (comment или issue) с привязкой через anchor
- **Comment** — комментарий к элементу ревью

**Типы целей ревью:**
- `diagram_version` — ревью версии диаграммы
- `source_file_version` — ревью версии исходного файла

**Типы элементов ревью:**
- `comment` — обычный комментарий
- `issue` — проблема, требующая решения

### Расширенное управление участниками

**ProjectMembersController** (`WebApi/Controllers/ProjectMembersController.cs`) предоставляет:

- Полный CRUD для участников проекта
- Изменение ролей с валидацией прав
- Передача владения проектом:
  - Старый owner автоматически становится admin
  - Новый owner получает полные права
  - Обновляется `OwnerId` в проекте
- Защита от некорректных операций:
  - Нельзя удалить owner
  - Нельзя понизить последнего admin до reviewer
  - Admin не может исключить самого себя

**Методы репозитория:**
- `GetByProjectIdAsync` — получить всех участников проекта
- `GetByProjectAndUserAsync` — найти конкретного участника
- `GetUserRoleAsync` — получить роль пользователя в проекте
- `IsMemberAsync` — проверить членство в проекте

### Реализованные сервисы

В `Infrastructure/Services/` реализованы:

- **AuthService** — аутентификация и регистрация пользователей
- **ReviewService** — полный цикл работы с ревью
- **InvitationService** — управление приглашениями

Все сервисы зарегистрированы в `DependencyInjection.cs` и доступны через DI.

### Реализованные репозитории

В `Infrastructure/Repositories/` реализованы репозитории для всех основных сущностей:

- ProjectRepository, ProjectMemberRepository
- ReviewRepository, ReviewItemRepository, CommentRepository
- UserRepository, DiagramRepository, SourceFileRepository
- LanguageRepository, InvitationRepository

Все репозитории используют общий базовый класс `EfRepository<T>` и работают через `AppDbContext`.

### Авторизация на основе ролей

**ProjectRoleHandler** (`WebApi/Authorization/ProjectRoleHandler.cs`) реализует проверку прав доступа:

- Определяет роль пользователя в проекте
- Учитывает видимость проекта (public/private)
- Проверяет соответствие роли требованиям политики
- Для публичных проектов разрешает доступ любому авторизованному пользователю

**Использование в контроллерах:**
```csharp
[Authorize(Policy = "ProjectRead")]  // Для чтения
[Authorize(Policy = "ProjectWrite")] // Для записи/создания
[Authorize(Policy = "ProjectAdmin")]  // Для административных операций
```

### Дополнительные возможности проектов

- **RequiredReviewersRules** — JSON строка с правилами обязательных ревьюеров
  - Формат: `[{"Role":"Admin","Count":2},{"Role":"Owner"}]`
  - Используется при создании ревью для проверки достаточности ревьюеров
  - Валидируется при создании/обновлении проекта

- **Visibility** — видимость проекта (private/public)
  - Влияет на доступность проекта для неавторизованных пользователей
  - Учитывается в политиках авторизации

Все эти нововведения интегрированы в существующую архитектуру и следуют принципам разделения ответственности между слоями.



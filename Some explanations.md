# Пояснения к структуре backend-проекта (.NET)

Здесь объяснены слои проекта, ключевые термины и как всё это связано между собой.

## 1) Из чего состоит проект

- `Domain` (Доменная модель)
  - Содержит классы-сущности предметной области: `User`, `Project`, `Diagram`, `SourceFile`, и т. д.
  - Здесь нет работы с базой данных и внешними сервисами — только данные и правила для этих данных.

- `Application` (Слой приложений)
  - Описывает контракты (интерфейсы) бизнес‑логики: сервисы (`IDiagramService`, `ISyncService` и др.) и репозитории (`IProjectRepository`, `IDiagramRepository`, …).
  - Здесь почти нет «реализаций» — в основном интерфейсы и DTO. Это позволяет легко подменять реализацию и тестировать логику.

- `Infrastructure` (Инфраструктура)
  - Реализует доступ к базе данных (EF Core), репозитории, Unit of Work, внешние интеграции.
  - Содержит `AppDbContext` — контекст базы данных.
  - В файле `DependencyInjection.cs` регистрируются реализации интерфейсов в контейнере зависимостей (см. DI).

- `WebApi` (Веб‑слой)
  - Точка входа в приложение (HTTP API).
  - `Program.cs` настраивает DI, БД, Swagger.
  - Здесь находятся контроллеры/эндпоинты, которые принимают запросы от фронтенда.


## 2) Ключевые термины

- DI (Dependency Injection) — «Внедрение зависимостей»
  - Способ передавать объектам их зависимости извне, а не создавать их внутри.
  - Мы регистрируем интерфейсы и их реализации (например, `IProjectRepository -> ProjectRepository`) в контейнере. Когда где‑то нужен `IProjectRepository`, контейнер создаёт `ProjectRepository` и передаёт его.
  - Плюсы: код легче тестировать и изменять, меньше «жёстких связей».

- Репозиторий (Repository)
  - Паттерн для инкапсуляции доступа к данным.
  - Интерфейс (например, `IProjectRepository`) описывает, что можно делать: «получить проект», «сохранить проект» и т. п.
  - Реализация (например, `ProjectRepository`) знает, как именно это сделать в БД (через EF Core).
  - Бонус: остальная логика не зависит от конкретной БД.

- Unit of Work (UoW) — «Единица работы»
  - Координирует сохранение изменений в БД как одну транзакцию.
  - Собираем несколько операций репозиториев и в конце одним вызовом `SaveChangesAsync()` фиксируем результат.
  - Это помогает обеспечить целостность: либо всё успешно, либо ничего не сохранено.

- DbContext (EF Core)
  - Класс EF Core, представляющий подключение к БД и набор таблиц (DbSet).
  - В проекте это `AppDbContext`: `Users`, `Projects`, `Diagrams`, …
  - Через контекст выполняются запросы, добавление/обновление/удаление данных.

- Миграции (EF Core Migrations)
  - Механизм версионирования схемы БД.
  - Команды: `dotnet ef migrations add <Имя>` — создать миграцию, `dotnet ef database update` — применить её к БД.
  - Мы уже сделали миграцию `Init` и применили её.

- Контроллер / Эндпоинт (Web API)
  - «Входные двери» в систему по HTTP (например, `GET /api/projects`).
  - Контроллер получает запрос, вызывает нужные сервисы/репозитории, возвращает ответ в формате JSON.

- DTO (Data Transfer Object)
  - Простые классы для передачи данных наружу/вовнутрь API (не обязательно совпадают с доменными сущностями).
  - Помогают отделить внутреннюю модель от внешнего контракта API.

- Swagger (OpenAPI)
  - Автоматическая документация и тестирование API через браузер.
  - Доступно на дев‑окружении. Удобно для изучения и ручной проверки эндпоинтов.


## 3) Как данные «идут» через слои

1. Клиент (например, фронтенд) вызывает HTTP эндпоинт WebApi.
2. Эндпоинт обращается к сервисам/репозиториям, объявленным в `Application` (по интерфейсам).
3. Контейнер DI подставляет реализации из `Infrastructure`.
4. Реализация через `AppDbContext` (EF Core) читает/пишет в БД.
5. Результат возвращается наверх, при необходимости маппится в DTO и отдается клиенту.


## 4) Где что зарегистрировано

- `WebApi/Program.cs`
  - Регистрация Swagger, чтение конфигурации, строка подключения к Postgres, `AddDbContext<AppDbContext>()`.
  - Вызов `builder.Services.AddInfrastructure();` — регистрирует репозитории и Unit of Work.

- `Infrastructure/DependencyInjection.cs`
  - Методы расширения для DI: `AddInfrastructure()` добавляет все реализации интерфейсов (`IProjectRepository`, `IDiagramRepository`, `IUnitOfWork`, и т. д.).


## 5) Как запустить и где настраивать БД

- Запуск API:
  - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
  - Откройте корневой эндпоинт `/` или Swagger в Dev‑режиме.

- Настройка строки подключения (PostgreSQL):
  - Файлы: `src/WebApi/appsettings.Development.json` (локально), `appsettings.json` (по умолчанию).
  - Можно задать через переменные окружения: `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`.


## 6) Куда смотреть студенту в первую очередь

1. `Domain/Entities` — понять, какие данные хранит система.
2. `Application/Repositories` — посмотреть, какие операции с данными требуются.
3. `Infrastructure/Repositories` — увидеть, как эти операции реализованы на EF Core.
4. `WebApi/Program.cs` — как подключается БД и DI, где включается Swagger.
5. Swagger UI — посмотреть и «пощупать» API запросами.


## 7) Частые вопросы

- Почему мы разделяем на слои?
  - Чтобы код было легче поддерживать, тестировать и расширять. Слои уменьшают «спутывание» зависимостей.

- Зачем интерфейсы и DI?
  - Можно подменить реализацию (например, на фейковую в тестах) без изменения остального кода.

- Чем сущность отличается от DTO?
  - Сущность — внутренняя модель (как мы храним/обрабатываем данные). DTO — внешний контракт (как мы отдаём/принимаем данные в API).

- Зачем Unit of Work?
  - Чтобы несколько операций сохранялись «атомарно» — либо все изменения вместе, либо ни одно.

Если остались вопросы — лучше всего открыть Swagger и пройтись по эндпоинтам, параллельно заглядывая в код соответствующих репозиториев/сервисов. Это быстро даст понимание, как всё связано. 

## 8) Как тестировать API через Swagger

Swagger уже подключён в Dev-окружении. Это удобный способ руками вызвать эндпоинты и увидеть структуру запросов/ответов.

Шаги:
1. Запустите API:
   - `dotnet run --project "DAOSS gh/src/WebApi/DAOSS.WebApi.csproj"`
2. Откройте браузер и перейдите:
   - Swagger UI: обычно `http://localhost:5143/swagger` (точный порт смотрите в `launchSettings.json`)
3. В Swagger UI:
   - Выберите нужный контроллер (например, `Projects`).
   - Раскройте метод (GET/POST/PUT/DELETE) и нажмите `Try it out`.
   - Заполните параметры/тело запроса и нажмите `Execute`.
   - Снизу увидите фактический запрос, статус-код и JSON-ответ.

Полезно:
- Вкладка `Schemas` показывает модели/DTO, которые использует API.
- Если метод требует body, Swagger подставит шаблон JSON — отредактируйте и отправьте.
- Для проверки соединения с БД начните с простых запросов `GET` (например, `GET /api/projects?ownerId=...`).

Альтернатива (curl/Postman):
- Любой запрос, показанный Swagger'ом, можно скопировать как cURL и выполнить в терминале, либо собрать вручную в Postman/Insomnia.


## 9) Нововведения и реализованный функционал

### Система ролей и прав доступа

Проект использует систему ролей для управления доступом:

- **Owner (Владелец)**
  - Полный контроль над проектом
  - Может передавать владение другому участнику
  - Может изменять роли всех участников
  - Не может быть исключен из проекта

- **Admin (Администратор)**
  - Может управлять участниками (добавлять, изменять роли, исключать)
  - Может отправлять приглашения
  - Не может передавать владение или изменять роль owner
  - Не может исключить самого себя

- **Reviewer (Ревьюер)**
  - Может просматривать проект и создавать ревью
  - Может комментировать элементы ревью
  - Не может управлять участниками

**Политики авторизации:**
- `ProjectRead` — доступ для public/reviewer/admin/owner
- `ProjectWrite` — доступ для public/reviewer/admin/owner (создание ревью, комментариев)
- `ProjectAdmin` — только admin и owner (управление участниками, настройками)

### Система приглашений (Invitations)

Реализован полноценный механизм приглашений пользователей в проекты:

- **InvitationService** (`Infrastructure/Services/InvitationService.cs`)
  - Отправка приглашений с указанием роли
  - Автоматическое истечение через 7 дней
  - Проверка дубликатов и прав доступа

- **InvitationsController** (`WebApi/Controllers/InvitationsController.cs`)
  - `POST /api/projects/{projectId}/invitations` — отправить приглашение
  - `GET /api/projects/{projectId}/invitations` — список приглашений проекта
  - `GET /api/invitations` — список приглашений текущего пользователя
  - `POST /api/invitations/{invitationId}/accept` — принять приглашение
  - `POST /api/invitations/{invitationId}/reject` — отклонить приглашение
  - `DELETE /api/projects/{projectId}/invitations/{invitationId}` — отменить приглашение

**Особенности:**
- При принятии приглашения пользователь автоматически добавляется в участники проекта
- Статусы: `pending`, `accepted`, `rejected`, `expired`, `canceled`
- Проверка прав: только admin/owner могут отправлять и отменять приглашения

### Система ревью (Reviews)

Реализована комплексная система ревью кода и диаграмм:

- **ReviewService** (`Infrastructure/Services/ReviewService.cs`)
  - Создание ревью для версий диаграмм или исходных файлов
  - Управление статусами ревью (open, approved, changes_requested)
  - Приоритизация ревьюеров на основе ролей
  - Валидация правил ревью из `RequiredReviewersRules`

- **ReviewsController** (`WebApi/Controllers/ReviewsController.cs`)
  - Управление ревью: создание, просмотр, обновление статуса, удаление
  - Управление элементами ревью (items): комментарии и issues с привязкой к коду/диаграмме
  - Система комментариев: добавление, просмотр, редактирование, удаление

**Структура ревью:**
- **Review** — основная сущность ревью (привязана к версии диаграммы или файла)
- **ReviewItem** — элемент ревью (comment или issue) с привязкой через anchor
- **Comment** — комментарий к элементу ревью

**Типы целей ревью:**
- `diagram_version` — ревью версии диаграммы
- `source_file_version` — ревью версии исходного файла

**Типы элементов ревью:**
- `comment` — обычный комментарий
- `issue` — проблема, требующая решения

### Расширенное управление участниками

**ProjectMembersController** (`WebApi/Controllers/ProjectMembersController.cs`) предоставляет:

- Полный CRUD для участников проекта
- Изменение ролей с валидацией прав
- Передача владения проектом:
  - Старый owner автоматически становится admin
  - Новый owner получает полные права
  - Обновляется `OwnerId` в проекте
- Защита от некорректных операций:
  - Нельзя удалить owner
  - Нельзя понизить последнего admin до reviewer
  - Admin не может исключить самого себя

**Методы репозитория:**
- `GetByProjectIdAsync` — получить всех участников проекта
- `GetByProjectAndUserAsync` — найти конкретного участника
- `GetUserRoleAsync` — получить роль пользователя в проекте
- `IsMemberAsync` — проверить членство в проекте

### Реализованные сервисы

В `Infrastructure/Services/` реализованы:

- **AuthService** — аутентификация и регистрация пользователей
- **ReviewService** — полный цикл работы с ревью
- **InvitationService** — управление приглашениями

Все сервисы зарегистрированы в `DependencyInjection.cs` и доступны через DI.

### Реализованные репозитории

В `Infrastructure/Repositories/` реализованы репозитории для всех основных сущностей:

- ProjectRepository, ProjectMemberRepository
- ReviewRepository, ReviewItemRepository, CommentRepository
- UserRepository, DiagramRepository, SourceFileRepository
- LanguageRepository, InvitationRepository

Все репозитории используют общий базовый класс `EfRepository<T>` и работают через `AppDbContext`.

### Авторизация на основе ролей

**ProjectRoleHandler** (`WebApi/Authorization/ProjectRoleHandler.cs`) реализует проверку прав доступа:

- Определяет роль пользователя в проекте
- Учитывает видимость проекта (public/private)
- Проверяет соответствие роли требованиям политики
- Для публичных проектов разрешает доступ любому авторизованному пользователю

**Использование в контроллерах:**
```csharp
[Authorize(Policy = "ProjectRead")]  // Для чтения
[Authorize(Policy = "ProjectWrite")] // Для записи/создания
[Authorize(Policy = "ProjectAdmin")]  // Для административных операций
```

### Дополнительные возможности проектов

- **RequiredReviewersRules** — JSON строка с правилами обязательных ревьюеров
  - Формат: `[{"Role":"Admin","Count":2},{"Role":"Owner"}]`
  - Используется при создании ревью для проверки достаточности ревьюеров
  - Валидируется при создании/обновлении проекта

- **Visibility** — видимость проекта (private/public)
  - Влияет на доступность проекта для неавторизованных пользователей
  - Учитывается в политиках авторизации

Все эти нововведения интегрированы в существующую архитектуру и следуют принципам разделения ответственности между слоями.

## 10) Работа с Git подмодулями

Проект использует Git подмодули для организации кода. Это репозиторий является подмодулем основного проекта и содержит вложенный подмодуль Parser.

### Клонирование с подмодулями

При первом клонировании основного репозитория:

```bash
git clone --recurse-submodules <URL_репозитория>
```

Если репозиторий уже склонирован без подмодулей:

```bash
git submodule update --init --recursive
```

### Автоматическая настройка подмодулей

Используйте скрипт из корня проекта:

```powershell
# Из корня DAoSS/
.\setup-submodules.ps1 -AddGitToPath
```

Скрипт автоматически:
- Инициализирует все подмодули (включая вложенные)
- Переключает `backend_and_parser` на ветку `backend_and_parser`
- Переключает вложенный подмодуль `Parser` на ветку `http-server_wip`
- Инициализирует подмодули внутри `backend_and_parser`

### Ручная настройка подмодулей

```bash
# Инициализация подмодулей первого уровня
git submodule update --init --recursive

# Переключение на нужную ветку
git checkout backend_and_parser

# Инициализация вложенных подмодулей
cd src/parser/Parser
git submodule update --init --recursive
git checkout http-server_wip
```

### Проблемы с вложенными подмодулями

**Проблема:** После клонирования вложенный подмодуль Parser не инициализирован.

**Решение:**
1. Используйте скрипт `setup-submodules.ps1` — он автоматически обрабатывает вложенные подмодули
2. Или вручную:
   ```bash
   cd backend_and_parser
   git submodule update --init --recursive
   ```

**Почему это происходит:** `git submodule update --init --recursive` из корня инициализирует только подмодули первого уровня. Вложенные подмодули нужно инициализировать отдельно после переключения на нужную ветку.

### Обновление подмодулей

```bash
# Обновить все подмодули до последних коммитов
git submodule update --remote --recursive

# Обновить конкретный подмодуль
cd backend_and_parser
git submodule update --remote src/parser/Parser
```

## 11) Скрипты автоматизации

Проект включает PowerShell скрипты для автоматизации рутинных задач.

### setup-submodules.ps1

Скрипт для настройки Git подмодулей.

**Расположение:** корень проекта `DAoSS/`

**Параметры:**
- `-Verbose` — подробный вывод операций
- `-AddGitToPath` — автоматически добавить Git в PATH (если Git не найден)

**Использование:**
```powershell
# Базовое использование
.\setup-submodules.ps1

# С автоматическим добавлением Git в PATH
.\setup-submodules.ps1 -AddGitToPath

# С подробным выводом
.\setup-submodules.ps1 -Verbose
```

**Что делает:**
1. Проверяет наличие Git в PATH
2. Инициализирует все подмодули рекурсивно
3. Переключает `backend_and_parser` на ветку `backend_and_parser`
4. Инициализирует подмодули внутри `backend_and_parser`
5. Переключает `Parser` на ветку `http-server_wip`

### start-all.ps1

Скрипт для последовательного запуска всех модулей проекта.

**Расположение:** корень проекта `DAoSS/`

**Параметры:**
- `-Verbose` — подробный вывод операций
- `-AddGitToPath` — автоматически добавить Git в PATH
- `-BuildParser` — собрать Parser перед запуском (cmake + build)
- `-BuildBackend` — собрать Backend перед запуском (dotnet build)
- `-UpdateMigrations` — применить миграции базы данных перед запуском Backend

**Использование:**
```powershell
# Базовый запуск (требует, чтобы всё уже было собрано)
.\start-all.ps1

# Полный запуск с подготовкой
.\start-all.ps1 -BuildParser -BuildBackend -UpdateMigrations

# Только сборка парсера
.\start-all.ps1 -BuildParser

# Только миграции
.\start-all.ps1 -UpdateMigrations

# С подробным выводом
.\start-all.ps1 -Verbose -BuildParser -BuildBackend -UpdateMigrations
```

**Порядок выполнения:**
1. Сборка Parser (если `-BuildParser`)
2. Запуск Parser (порт 8080)
3. Применение миграций (если `-UpdateMigrations`)
4. Сборка Backend (если `-BuildBackend`)
5. Запуск Backend (порты 5143/7143)
6. Запуск Frontend (порт 5173)

**Особенности:**
- Все ошибки выводятся в реальном времени
- При завершении процесса с ошибкой выводится полный лог
- При Ctrl+C все процессы корректно останавливаются

## 12) Нюансы работы с миграциями

### Когда применять миграции

- **При первом запуске проекта** — обязательно применить все миграции
- **После получения изменений из репозитория** — если были добавлены новые миграции
- **После создания новой миграции** — применить её к базе данных

### Применение миграций

**Через скрипт:**
```powershell
.\start-all.ps1 -UpdateMigrations
```

**Вручную:**
```bash
cd src/WebApi
dotnet ef database update --project DAOSS.WebApi.csproj
```

### Создание новой миграции

```bash
cd src/WebApi
dotnet ef migrations add <ИмяМиграции> --project DAOSS.WebApi.csproj
```

**Важно:** Имя миграции должно быть описательным, например: `AddUserEmailIndex`, `UpdateProjectSchema`.

### Проблемы с миграциями

**Проблема:** Ошибка "No migrations found"

**Решение:**
- Убедитесь, что находитесь в правильной директории (`src/WebApi`)
- Проверьте, что файлы миграций существуют в `Infrastructure/Migrations/`

**Проблема:** Ошибка подключения к базе данных

**Решение:**
- Проверьте строку подключения в `appsettings.Development.json`
- Убедитесь, что PostgreSQL запущен
- Проверьте права доступа пользователя БД

**Проблема:** Конфликт миграций

**Решение:**
- Если миграция уже применена, но код пытается применить её снова — это нормально, EF Core пропустит
- Если нужно откатить миграцию:
  ```bash
  dotnet ef database update <ПредыдущаяМиграция> --project DAOSS.WebApi.csproj
  ```

### Работа с несколькими окружениями

Для разных окружений используйте разные строки подключения:

- **Development:** `appsettings.Development.json`
- **Production:** `appsettings.Production.json` или переменные окружения

Применяйте миграции отдельно для каждого окружения.

## 13) Нюансы работы с парсером

### Порядок запуска

**Важно:** Парсер должен быть запущен **перед** Backend, так как Backend делает HTTP запросы к парсеру при инициализации некоторых сервисов.

**Правильный порядок:**
1. Parser (порт 8080)
2. Backend (порты 5143/7143)
3. Frontend (порт 5173)

### Проблемы с портами

**Проблема:** Порт 8080 занят

**Проверка:**
```bash
# Windows
netstat -ano | findstr :8080

# Linux/macOS
lsof -i :8080
```

**Решение:**
- Остановите процесс, занимающий порт
- Или измените порт парсера (требует изменения в Backend)

**Проблема:** Backend не может подключиться к парсеру

**Проверка:**
- Убедитесь, что парсер запущен
- Проверьте URL в настройках Backend (по умолчанию `http://localhost:8080`)
- Проверьте firewall/брандмауэр

### Отладка парсера

**Логи:**
- Парсер выводит все логи в консоль
- Ошибки парсинга возвращаются в ответе API
- HTTP ошибки логируются в консоль

**Тестирование:**
```bash
curl http://localhost:8080/api/validate/simple \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{"code":"program Test; begin end.","language":"pascal"}'
```

**Проверка работоспособности:**
- Парсер должен отвечать на запросы
- Проверьте, что JWT токен валиден
- Убедитесь, что код на поддерживаемом языке

### Сборка парсера

**Требования:**
- CMake 3.15+
- C++ компилятор с поддержкой C++17

**Автоматическая сборка:**
```powershell
.\start-all.ps1 -BuildParser
```

**Ручная сборка:**
```bash
cd src/parser/Parser
mkdir build && cd build
cmake ..
cmake --build . --config Release
```

## 14) Нюансы работы с базой данных

### Настройка строки подключения

**Файлы конфигурации:**
- `src/WebApi/appsettings.Development.json` — для локальной разработки
- `src/WebApi/appsettings.json` — значения по умолчанию

**Формат строки подключения:**
```
Host=localhost;Port=5432;Database=daoss;Username=postgres;Password=your_password
```

**Переменные окружения:**
- `POSTGRES_HOST`
- `POSTGRES_PORT`
- `POSTGRES_DB`
- `POSTGRES_USER`
- `POSTGRES_PASSWORD`

### Работа с несколькими БД

Для разных окружений используйте разные базы данных:

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=daoss_dev;Username=postgres;Password=dev_password"
  }
}
```

**Важно:** Применяйте миграции отдельно для каждой БД.

### Резервное копирование

**Создание бэкапа:**
```bash
pg_dump -h localhost -U postgres -d daoss > backup.sql
```

**Восстановление:**
```bash
psql -h localhost -U postgres -d daoss < backup.sql
```

### Проверка подключения

```bash
# Проверить, что PostgreSQL запущен
# Windows
pg_ctl status

# Linux
sudo systemctl status postgresql

# macOS
brew services list | grep postgresql

# Подключиться к БД
psql -h localhost -U postgres -d daoss
```

## 15) Отладка и troubleshooting

### Частые ошибки и их решения

**Ошибка:** "Unable to connect to database"

**Решение:**
- Проверьте, что PostgreSQL запущен
- Проверьте строку подключения
- Проверьте права доступа пользователя

**Ошибка:** "Migration already applied"

**Решение:**
- Это нормально, EF Core пропускает уже применённые миграции
- Если нужно применить заново, сначала откатите миграцию

**Ошибка:** "Parser service unavailable"

**Решение:**
- Убедитесь, что парсер запущен на порту 8080
- Проверьте URL в настройках Backend
- Проверьте логи парсера

**Ошибка:** "JWT token invalid"

**Решение:**
- Проверьте, что токен не истёк
- Убедитесь, что используется правильный секретный ключ
- Проверьте формат токена

### Логи и где их искать

**Backend:**
- Логи выводятся в консоль при запуске через `dotnet run`
- В Production можно настроить логирование в файл через `appsettings.Production.json`

**Parser:**
- Все логи выводятся в консоль
- Ошибки парсинга возвращаются в ответе API

**Frontend:**
- Логи в консоли браузера (F12)
- Логи сборки в терминале

### Проверка работоспособности компонентов

**Backend:**
```bash
# Проверить, что API отвечает
curl http://localhost:5143/api/auth/me \
  -H "Authorization: Bearer <token>"
```

**Parser:**
```bash
# Проверить, что парсер отвечает
curl http://localhost:8080/api/validate/simple \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{"code":"program Test; begin end.","language":"pascal"}'
```

**Frontend:**
- Откройте `http://localhost:5173` в браузере
- Проверьте консоль браузера на ошибки

**База данных:**
```bash
# Подключиться к БД и проверить таблицы
psql -h localhost -U postgres -d daoss
\dt  # Список таблиц
```

## 16) Работа с ветками

### Какие ветки используются

- **Основной проект:** ветка `main` или `frontend_wip` (зависит от репозитория)
- **Backend (`backend_and_parser`):** ветка `backend_and_parser`
- **Parser (`src/parser/Parser`):** ветка `http-server_wip`

### Переключение между ветками

**Автоматическое переключение:**
```powershell
.\setup-submodules.ps1
```

**Ручное переключение:**
```bash
# В основном репозитории
git checkout <ветка>

# В подмодуле backend_and_parser
cd backend_and_parser
git checkout backend_and_parser

# Во вложенном подмодуле Parser
cd src/parser/Parser
git checkout http-server_wip
```

### Синхронизация изменений

**Получение изменений:**
```bash
# В основном репозитории
git pull

# Обновить подмодули до коммитов, указанных в основном репозитории
git submodule update --recursive

# Обновить подмодули до последних коммитов в их ветках
git submodule update --remote --recursive
```

**Отправка изменений:**
```bash
# В подмодуле
cd backend_and_parser
git add .
git commit -m "Описание изменений"
git push origin backend_and_parser

# В основном репозитории (обновить ссылку на подмодуль)
cd ..
git add backend_and_parser
git commit -m "Update backend_and_parser submodule"
git push
```

**Важно:** При работе с подмодулями изменения нужно коммитить в каждом репозитории отдельно, а затем обновлять ссылку в родительском репозитории.

